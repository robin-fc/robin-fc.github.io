"use strict";(self.webpackChunkrobin_fc_github_io=self.webpackChunkrobin_fc_github_io||[]).push([[4418],{6995:(t,e)=>{e.A=(t,e)=>{const c=t.__vccOpts||t;for(const[t,o]of e)c[t]=o;return c}},9249:(t,e,c)=>{c.r(e),c.d(e,{comp:()=>a,data:()=>i});var o=c(6254);const n={},a=(0,c(6995).A)(n,[["render",function(t,e){return(0,o.uX)(),(0,o.CE)("div",null,e[0]||(e[0]=[(0,o.Lk)("ol",null,[(0,o.Lk)("li",null,"React 的事件机制 React 本身使用了顶层事件委托，无论你是否手动绑定到父元素：")],-1),(0,o.Lk)("p",null,"所有事件默认被委托到 document（或 React 17+ 的根容器）。",-1),(0,o.Lk)("p",null,"即使你在循环中为每个子元素写 onClick={...}，React 并不会真正绑定多个 DOM 事件监听器。",-1),(0,o.Lk)("p",null,"实际性能损耗不在 DOM 层，而是在 React 的事件处理逻辑和组件渲染上。",-1)]))}]]),i=JSON.parse('{"path":"/%E5%B7%A5%E4%BD%9C/%E9%9D%A2%E8%AF%95/","title":"面试","lang":"zh-CN","frontmatter":{"article":false,"title":"面试","icon":"fa6-solid:book-open-reader","description":"React 的事件机制 React 本身使用了顶层事件委托，无论你是否手动绑定到父元素： 所有事件默认被委托到 document（或 React 17+ 的根容器）。 即使你在循环中为每个子元素写 onClick={...}，React 并不会真正绑定多个 DOM 事件监听器。 实际性能损耗不在 DOM 层，而是在 React 的事件处理逻辑和组件渲染上。","head":[["meta",{"property":"og:url","content":"https://github.com/robin-fc/robin-fc.github.io/%E5%B7%A5%E4%BD%9C/%E9%9D%A2%E8%AF%95/"}],["meta",{"property":"og:site_name","content":"FC的博客"}],["meta",{"property":"og:title","content":"面试"}],["meta",{"property":"og:description","content":"React 的事件机制 React 本身使用了顶层事件委托，无论你是否手动绑定到父元素： 所有事件默认被委托到 document（或 React 17+ 的根容器）。 即使你在循环中为每个子元素写 onClick={...}，React 并不会真正绑定多个 DOM 事件监听器。 实际性能损耗不在 DOM 层，而是在 React 的事件处理逻辑和组件渲染上。"}],["meta",{"property":"og:type","content":"website"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-04-16T03:52:16.000Z"}],["meta",{"property":"article:modified_time","content":"2025-04-16T03:52:16.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"WebPage\\",\\"name\\":\\"面试\\",\\"description\\":\\"React 的事件机制 React 本身使用了顶层事件委托，无论你是否手动绑定到父元素： 所有事件默认被委托到 document（或 React 17+ 的根容器）。 即使你在循环中为每个子元素写 onClick={...}，React 并不会真正绑定多个 DOM 事件监听器。 实际性能损耗不在 DOM 层，而是在 React 的事件处理逻辑和组件渲染上。\\"}"]]},"git":{"createdTime":1741536402000,"updatedTime":1744775536000,"contributors":[{"name":"victor","username":"victor","email":"40204871+robin-fc@users.noreply.github.com","commits":1,"url":"https://github.com/victor"},{"name":"robin-fc","username":"robin-fc","email":"873602646@qq.com","commits":1,"url":"https://github.com/robin-fc"}]},"readingTime":{"minutes":0.4,"words":120},"filePathRelative":"工作/面试/README.md","localizedDate":"2025年3月9日","excerpt":"<ol>\\n<li>React 的事件机制\\nReact 本身使用了顶层事件委托，无论你是否手动绑定到父元素：</li>\\n</ol>\\n<p>所有事件默认被委托到 document（或 React 17+ 的根容器）。</p>\\n<p>即使你在循环中为每个子元素写 onClick={...}，React 并不会真正绑定多个 DOM 事件监听器。</p>\\n<p>实际性能损耗不在 DOM 层，而是在 React 的事件处理逻辑和组件渲染上。</p>\\n","autoDesc":true}')}}]);